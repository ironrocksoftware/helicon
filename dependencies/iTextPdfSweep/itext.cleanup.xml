<?xml version="1.0"?>
<doc>
    <assembly>
        <name>itext.cleanup</name>
    </assembly>
    <members>
        <member name="T:iText.PdfCleanup.Autosweep.CommonRegex">
            <summary>This class contains some of the more common regular expressions to be used for redaction.</summary>
            <remarks>
            This class contains some of the more common regular expressions to be used for redaction.
            Most of these are copied verbatim from the "regular expression cookbook 2nd edition".
            </remarks>
        </member>
        <member name="T:iText.PdfCleanup.Autosweep.CompositeCleanupStrategy">
            <summary>
            This class is a composite pattern for
            <c>ICleanupStrategy</c>
            It allows users to have multiple ICleanupStrategy implementations and bundle them as one.
            </summary>
        </member>
        <member name="T:iText.PdfCleanup.Autosweep.ICleanupStrategy">
            <summary>
            This class represents a generic cleanup strategy to be used with
            <see cref="T:iText.PdfCleanup.Autosweep.PdfAutoSweep"/>
            ICleanupStrategy must implement Cloneable to ensure a strategy can be reset after having handled a page.
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.ICleanupStrategy.GetRedactionColor(iText.Kernel.Pdf.Canvas.Parser.Listener.IPdfTextLocation)">
            <summary>Get the color in which redaction is to take place</summary>
            <param name="location">where to get the redaction color from</param>
            <returns>
            a
            <see cref="T:iText.Kernel.Colors.Color"/>
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.ICleanupStrategy.Reset">
            <summary>
            ICleanupStrategy objects have to be reset at times
            <c>PdfAutoSweep</c>
            will use the same strategy for all pages,
            and expects to receive only the rectangles from the last page as output.
            </summary>
            <remarks>
            ICleanupStrategy objects have to be reset at times
            <c>PdfAutoSweep</c>
            will use the same strategy for all pages,
            and expects to receive only the rectangles from the last page as output.
            Hence the reset method.
            </remarks>
            <returns>a clone of this Object</returns>
        </member>
        <member name="T:iText.PdfCleanup.Autosweep.PdfAutoSweep">
            <summary>Class that automatically extracts all regions of interest from a given PdfDocument and redacts them.
                </summary>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.#ctor(iText.PdfCleanup.Autosweep.ICleanupStrategy)">
            <summary>Construct a new instance of PdfAutoSweep with a given ICleanupStrategy</summary>
            <param name="strategy">the redaction strategy to be used</param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.GetPdfCleanUpLocations(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Get all
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            objects from a given
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            </summary>
            <param name="page">
            the
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to be processed
            </param>
            <returns>
            a List of
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            objects
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.GetPdfCleanUpLocations(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Get all
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            objects from a given
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            </summary>
            <param name="doc">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            to be processed
            </param>
            <returns>
            a List of
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            objects
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.Highlight(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Highlight areas of interest in a given
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            </summary>
            <param name="pdfDocument">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            to be highlighted
            </param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.Highlight(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Highlight areas of interest in a given
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            </summary>
            <param name="pdfPage">
            the
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to be highlighted
            </param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.CleanUp(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Perform cleanup of areas of interest on a given
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            </summary>
            <param name="pdfDocument">
            the
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            to be redacted
            </param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.CleanUp(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Perform cleanup of areas of interest on a given
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            </summary>
            <param name="pdfPage">
            the
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            to be redacted
            </param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.TentativeCleanUp(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Perform tentative cleanup of areas of interest on a given
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            This method will add all redaction annotations to the given document, allowing
            the end-user to choose which redactions to keep or delete.
            </summary>
            <param name="pdfDocument">the document to clean up</param>
        </member>
        <member name="M:iText.PdfCleanup.Autosweep.PdfAutoSweep.TentativeCleanUp(iText.Kernel.Pdf.PdfPage)">
            <summary>
            Perform tentative cleanup of areas of interest on a given
            <see cref="T:iText.Kernel.Pdf.PdfPage"/>
            This method will add all redaction annotations to the given page, allowing
            the end-user to choose which redactions to keep or delete.
            </summary>
            <param name="pdfPage">the page to clean up</param>
        </member>
        <member name="T:iText.PdfCleanup.Autosweep.RegexBasedCleanupStrategy">
            <summary>This class represents a regular expression based cleanup strategy</summary>
        </member>
        <member name="F:iText.PdfCleanup.CleanUpLogMessageConstant.CANNOT_OBTAIN_IMAGE_INFO_AFTER_FILTERING">
            <summary>The Constant CANNOT_OBTAIN_IMAGE_INFO_AFTER_FILTERING.</summary>
        </member>
        <member name="F:iText.PdfCleanup.CleanUpLogMessageConstant.FAILED_TO_PROCESS_A_TRANSFORMATION_MATRIX">
            <summary>The Constant FAILED_TO_PROCESS_A_TRANSFORMATION_MATRIX.</summary>
        </member>
        <member name="F:iText.PdfCleanup.CleanUpLogMessageConstant.IMAGE_MASK_CLEAN_UP_NOT_SUPPORTED">
            <summary>The Constant IMAGE_MASK_CLEAN_UP_NOT_SUPPORTED.</summary>
        </member>
        <member name="F:iText.PdfCleanup.CleanUpLogMessageConstant.REDACTION_OF_ANNOTATION_TYPE_WATERMARK_IS_NOT_SUPPORTED">
            <summary>The Constant REDACTION_OF_ANNOTATION_TYPE_WATERMARK_IS_NOT_SUPPORTED.</summary>
        </member>
        <member name="M:iText.PdfCleanup.FilteredImagesCache.Get(iText.PdfCleanup.FilteredImagesCache.FilteredImageKey)">
            <summary>Retrieves saved result of image filtering based on given set of cleaning areas.</summary>
            <remarks>
            Retrieves saved result of image filtering based on given set of cleaning areas.
            This won't handle the case when same filtering result is produced by different sets of areas,
            e.g. if one set is { (0, 0, 50, 100), (50, 0, 50, 100)} and another one is {(0, 0, 100, 100)},
            even though filtering results are essentially the same, current
            <see cref="T:iText.PdfCleanup.FilteredImagesCache"/>
            will treat this two cases as different filtering results.
            </remarks>
            <param name="imageKey">the defining filtering case</param>
            <returns>
            result of image filtering based on given set of cleaning areas if such was already processed and saved,
            null otherwise.
            </returns>
        </member>
        <member name="T:iText.PdfCleanup.LineDashPattern">
            <summary>Represents the line dash pattern.</summary>
            <remarks>
            Represents the line dash pattern. The line dash pattern shall control the pattern
            of dashes and gaps used to stroke paths. It shall be specified by a dash array and
            a dash phase.
            </remarks>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.#ctor(iText.Kernel.Pdf.PdfArray,System.Single)">
            <summary>
            Creates new
            <see cref="T:iText.PdfCleanup.LineDashPattern"/>
            object.
            </summary>
            <param name="dashArray">
            The dash array. See
            <see cref="M:iText.PdfCleanup.LineDashPattern.GetDashArray"/>
            </param>
            <param name="dashPhase">
            The dash phase. See
            <see cref="M:iText.PdfCleanup.LineDashPattern.GetDashPhase"/>
            </param>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.GetDashArray">
            <summary>Getter for the dash array.</summary>
            <remarks>
            Getter for the dash array.
            <para />
            The dash array’s elements is number that specify the lengths of
            alternating dashes and gaps; the numbers are nonnegative. The
            elements are expressed in user space units.
            </remarks>
            <returns>The dash array.</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.SetDashArray(iText.Kernel.Pdf.PdfArray)">
            <summary>Setter for the dash array.</summary>
            <remarks>
            Setter for the dash array. See
            <see cref="M:iText.PdfCleanup.LineDashPattern.GetDashArray"/>
            </remarks>
            <param name="dashArray">New dash array.</param>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.GetDashPhase">
            <summary>Getter for the dash phase.</summary>
            <remarks>
            Getter for the dash phase.
            <para />
            The dash phase shall specify the distance into the dash pattern at which
            to start the dash. The elements are expressed in user space units.
            </remarks>
            <returns>The dash phase.</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.SetDashPhase(System.Single)">
            <summary>Setter for the dash phase.</summary>
            <remarks>
            Setter for the dash phase. See
            <see cref="M:iText.PdfCleanup.LineDashPattern.GetDashArray"/>
            </remarks>
            <param name="dashPhase">New dash phase.</param>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.Next">
            <summary>Calculates and returns the next element which is either gap or dash.</summary>
            <returns>The next dash array's element.</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.Reset">
            <summary>
            Resets the dash array so that the
            <see cref="M:iText.PdfCleanup.LineDashPattern.Next"/>
            method will start
            from the beginning of the dash array.
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.IsSolid">
            <summary>Checks whether the dashed pattern is solid or not.</summary>
            <remarks>
            Checks whether the dashed pattern is solid or not. It's solid when the
            size of a dash array is even and sum of all the units off in the array
            is 0.
            For example: [3 0 4 0 5 0 6 0] (sum is 0), [3 0 4 0 5 1] (sum is 1).
            </remarks>
            <returns>is the dashed pattern solid or not</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.IsEven(System.Int32)">
            <summary>Return whether or not a given number is even</summary>
            <param name="num">input number</param>
            <returns>true if the input number is even, false otherwise</returns>
        </member>
        <member name="T:iText.PdfCleanup.LineDashPattern.DashArrayElem">
            <summary>Class representing a single element of a dash array</summary>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.DashArrayElem.#ctor(iText.PdfCleanup.LineDashPattern,System.Single,System.Boolean)">
            <summary>Construct a new DashArrayElem object</summary>
            <param name="val">the length of the dash array element</param>
            <param name="isGap">whether this element indicates a gap, or a stroke</param>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.ApplyDashPattern(iText.Kernel.Geom.Path,iText.PdfCleanup.LineDashPattern)">
            <summary>Apply a LineDashPattern along a Path</summary>
            <param name="path">input path</param>
            <param name="lineDashPattern">input LineDashPattern</param>
            <returns>a dashed Path</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.ComponentwiseDiff(iText.Kernel.Geom.Point,iText.Kernel.Geom.Point)">
            <summary>Returns the componentwise difference between two vectors</summary>
            <param name="minuend">first vector</param>
            <param name="subtrahend">second vector</param>
            <returns>first vector .- second vector</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.GetUnitVector(iText.Kernel.Geom.Point)">
            <summary>Construct a unit vector from a given vector</summary>
            <param name="vector">input vector</param>
            <returns>a vector of length 1, with the same orientation as the original vector</returns>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.GetVectorEuclideanNorm(iText.Kernel.Geom.Point)">
            <summary>Returns the Euclidean vector norm.</summary>
            <remarks>
            Returns the Euclidean vector norm.
            This is the Euclidean distance between the tip of the vector and the origin.
            </remarks>
            <param name="vector">input vector</param>
        </member>
        <member name="M:iText.PdfCleanup.LineDashPattern.LiesOnSegment(iText.Kernel.Geom.Point,iText.Kernel.Geom.Point,iText.Kernel.Geom.Point)">
            <summary>Returns whether a given point lies on a line-segment specified by start and end point</summary>
            <param name="segStart">start of the line segment</param>
            <param name="segEnd">end of the line segment</param>
            <param name="point">query point</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpEventListener.GetEncounteredText">
            <summary>Get the last encountered TextRenderInfo objects, then clears the internal buffer</summary>
            <returns>the TextRenderInfo objects that were encountered when processing the last text rendering operation
                </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpEventListener.GetEncounteredImage">
            <summary>Get the last encountered ImageRenderInfo, then clears the internal buffer</summary>
            <returns>the ImageRenderInfo object that was encountered when processing the last image rendering operation
                </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpEventListener.GetEncounteredPath">
            <summary>Get the last encountered PathRenderInfo, then clears the internal buffer</summary>
            <returns>the PathRenderInfo object that was encountered when processing the last path rendering operation</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterText(iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo)">
            <summary>Filter a TextRenderInfo object</summary>
            <param name="text">the TextRenderInfo to be filtered</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterImage(iText.Kernel.Pdf.Canvas.Parser.Data.ImageRenderInfo)">
            <summary>Filter an ImageRenderInfo object</summary>
            <param name="image">the ImageRenderInfo object to be filtered</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterStrokePath(iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo)">
            <summary>Filter a PathRenderInfo object</summary>
            <param name="path">the PathRenderInfo object to be filtered</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterFillPath(iText.Kernel.Pdf.Canvas.Parser.Data.PathRenderInfo,System.Int32)">
            <summary>Filter a PathRenderInfo object</summary>
            <param name="path">the PathRenderInfo object to be filtered</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.IsTextNotToBeCleaned(iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo)">
            <summary>Returns whether the given TextRenderInfo object needs to be cleaned up</summary>
            <param name="renderInfo">the input TextRenderInfo object</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.GetImageAreasToBeCleaned(iText.Kernel.Geom.Matrix)">
            <summary>Calculates intersection of the image and the render filter region in the coordinate system relative to the image.
                </summary>
            <returns>
            <code>null</code> if the image is fully covered and therefore is completely cleaned,
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            of
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            objects otherwise.
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterFillPath(iText.Kernel.Geom.Path,iText.Kernel.Geom.Matrix,System.Int32)">
            <summary>Note: this method will close all unclosed subpaths of the passed path.</summary>
            <param name="fillingRule">If the subpath is contour, pass any value.</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.CheckIfRectanglesIntersect(iText.Kernel.Geom.Point[],iText.Kernel.Geom.Point[])">
            <summary>Return true if two given rectangles (specified by an array of points) intersect.</summary>
            <param name="rect1">the first rectanglee, considered as a subject of intersection. Even if it's width is zero,
            it still can be intersected by second rectangle.</param>
            <param name="rect2">the second rectangle, considered as intersecting rectangle. If it has zero width rectangles
            are never considered as intersecting.</param>
            <returns>true if the rectangles intersect, false otherwise</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.CalcImageRect(iText.Kernel.Geom.Matrix)">
            <returns>Image boundary rectangle in device space.</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.TransformRectIntoImageCoordinates(iText.Kernel.Geom.Rectangle,iText.Kernel.Geom.Matrix)">
            <summary>Transforms the given Rectangle into the image coordinate system which is [0,1]x[0,1] by default</summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.ProcessImage(System.Byte[],System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle})">
            <summary>Clean up an image using a List of Rectangles that need to be redacted</summary>
            <param name="imageBytes">the image to be cleaned up</param>
            <param name="areasToBeCleaned">the List of Rectangles that need to be redacted out of the image</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.ProcessImageDirectly(iText.Kernel.Pdf.Xobject.PdfImageXObject,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle})">
            <summary>
            Filters image content using direct manipulation over PDF image samples stream. Implemented according to ISO 32000-2,
            "8.9.3 Sample representation".
            </summary>
            <param name="image">image XObject which will be filtered</param>
            <param name="imageAreasToBeCleaned">list of rectangle areas for clean up with coordinates in (0,1)x(0,1) space</param>
            <returns>raw bytes of the PDF image samples stream which is already cleaned.</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.CleanImage(System.Drawing.Image,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle})">
            <summary>Clean up a BufferedImage using a List of Rectangles that need to be redacted</summary>
            <param name="image">the image to be cleaned up</param>
            <param name="areasToBeCleaned">the List of Rectangles that need to be redacted out of the image</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.ConvertToCircles(System.Collections.Generic.IList{iText.Kernel.Geom.Subpath},System.Double)">
            <summary>Converts specified degenerate subpaths to circles.</summary>
            <remarks>
            Converts specified degenerate subpaths to circles.
            Note: actually the resultant subpaths are not real circles but approximated.
            </remarks>
            <param name="radius">Radius of each constructed circle.</param>
            <returns>
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            consisting of circles constructed on given degenerated subpaths.
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.ConvertToSquares(System.Collections.Generic.IList{iText.Kernel.Geom.Subpath},System.Double,iText.Kernel.Geom.Path)">
            <summary>Converts specified degenerate subpaths to squares.</summary>
            <remarks>
            Converts specified degenerate subpaths to squares.
            Note: the list of degenerate subpaths should contain at least 2 elements. Otherwise
            we can't determine the direction which the rotation of each square depends on.
            </remarks>
            <param name="squareWidth">Width of each constructed square.</param>
            <param name="sourcePath">The path which dash pattern applied to. Needed to calc rotation angle of each square.
                </param>
            <returns>
            
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            consisting of squares constructed on given degenerated subpaths.
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.GetPathApproximation(iText.Kernel.Geom.Path)">
            <summary>Approximates a given Path with a List of Point objects</summary>
            <param name="path">input path</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.ApproximateCircle(iText.Kernel.Geom.Point,System.Double)">
            <summary>Approximate a circle with 4 Bezier curves (one for each 90 degrees sector)</summary>
            <param name="center">center of the circle</param>
            <param name="radius">radius of the circle</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.GetTextRectangle(iText.Kernel.Pdf.Canvas.Parser.Data.TextRenderInfo)">
            <summary>Get the bounding box of a TextRenderInfo object</summary>
            <param name="renderInfo">input TextRenderInfo object</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.GetRectangleVertices(iText.Kernel.Geom.Rectangle)">
            <summary>Convert a Rectangle object into 4 Points</summary>
            <param name="rect">input Rectangle</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.GetRectanglesIntersection(iText.Kernel.Geom.Rectangle,iText.Kernel.Geom.Rectangle)">
            <summary>Calculate the intersection of 2 Rectangles</summary>
            <param name="rect1">first Rectangle</param>
            <param name="rect2">second Rectangle</param>
        </member>
        <member name="T:iText.PdfCleanup.PdfCleanUpFilter.FilterResult`1">
            <summary>Generic class representing the result of filtering an object of type T</summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterResult`1.IsModified">
            <summary>Get whether the object was modified or not</summary>
            <returns>true if the object was modified, false otherwise</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpFilter.FilterResult`1.GetFilterResult">
            <summary>Get the result after filtering</summary>
        </member>
        <member name="T:iText.PdfCleanup.PdfCleanUpLocation">
            <summary>Defines the region to be erased in a PDF document.</summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpLocation.#ctor(System.Int32,iText.Kernel.Geom.Rectangle)">
            <summary>
            Constructs a
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            object.
            </summary>
            <param name="page">specifies the number of the page which the region belongs to.</param>
            <param name="region">represents the boundaries of the area to be erased.</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpLocation.#ctor(System.Int32,iText.Kernel.Geom.Rectangle,iText.Kernel.Colors.Color)">
            <summary>
            Constructs a
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            object.
            </summary>
            <param name="page">specifies the number of the page which the region belongs to.</param>
            <param name="region">represents the boundaries of the area to be erased.</param>
            <param name="cleanUpColor">
            a color used to fill the area after erasing it. If
            <see langword="null"/>
            the erased area left uncolored.
            </param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpLocation.GetPage">
            <returns>the number of the page which the region belongs to.</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpLocation.GetRegion">
            <returns>
            A
            <see cref="T:iText.Kernel.Geom.Rectangle"/>
            representing the boundaries of the area to be erased.
            </returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpLocation.GetCleanUpColor">
            <summary>Returns a color used to fill the area after erasing it.</summary>
            <remarks>
            Returns a color used to fill the area after erasing it. If
            <see langword="null"/>
            the erased area left uncolored.
            </remarks>
            <returns>a color used to fill the area after erasing it.</returns>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanUpProcessor.notAppliedGsParams">
            <summary>
            In
            <c>notAppliedGsParams</c>
            field not written graphics state params are stored.
            </summary>
            <remarks>
            In
            <c>notAppliedGsParams</c>
            field not written graphics state params are stored.
            Stack represents gs params on different levels of the q/Q nesting (see
            <see cref="T:iText.PdfCleanup.PdfCleanUpProcessor.NotAppliedGsParams"/>
            ).
            On "q" operator new
            <c>NotAppliedGsParams</c>
            is pushed to the stack and on "Q" it is popped.
            <para />
            When operators are applied, they are written from the outer to inner nesting level, separated by "q".
            After being written the stack is cleared.
            <para />
            Graphics state parameters are applied in two ways:
            <list type="bullet">
            <item><description>
            first - right before writing text content, text state in current gs is compare to the text state of the text
            render info gs and difference is applied to current gs;
            </description></item>
            <item><description>
            second - through list of the not applied gs params. Right before writing some content, this list is checked,
            and if something affecting content is stored in this list it will be applied.
            </description></item>
            </list>
            </remarks>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpProcessor.ProcessPageAnnotations(iText.Kernel.Pdf.PdfPage,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle})">
            <summary>Process the annotations of a page.</summary>
            <remarks>
            Process the annotations of a page.
            Default process behaviour is to remove the annotation if there is (partial) overlap with a redaction region
            </remarks>
            <param name="page">the page to process</param>
            <param name="regions">a list of redaction regions</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpProcessor.ProcessPageAnnotations(iText.Kernel.Pdf.PdfPage,System.Collections.Generic.IList{iText.Kernel.Geom.Rectangle},System.Boolean)">
            <summary>Process the annotations of a page.</summary>
            <remarks>
            Process the annotations of a page.
            Default process behaviour is to remove the annotation if there is (partial) overlap with a redaction region
            </remarks>
            <param name="page">the page to process</param>
            <param name="regions">a list of redaction regions</param>
            <param name="redactRedactAnnotations">true if annotation with subtype /Redact should also be removed</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpProcessor.ProcessContent(System.Byte[],iText.Kernel.Pdf.PdfResources)">
            <param name="contentBytes">the bytes of a content stream</param>
            <param name="resources">the resources of the content stream. Must not be null.</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpProcessor.QuadPointsForLinkAnnotationAreValid(iText.Kernel.Geom.Rectangle,iText.Kernel.Pdf.PdfArray)">
            <summary>
            For a link annotation, a quadpoints array can be specified
            but it will be ignored in favour of the rectangle
            if one of the points is located outside the rectangle's boundaries
            </summary>
            <param name="rect">rectangle entry of the link annotation</param>
            <param name="quadPoints">
            An array of 8 × n numbers specifying the coordinates of n quadrilaterals
            in default user space that comprise the region in which the link should be activated.
            </param>
            <returns>true if the quad points are valid, false if the quadpoint array should be used</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpProcessor.PollNotAppliedCtm">
            <summary>To add images and formXObjects to canvas we pass ctm.</summary>
            <remarks>
            To add images and formXObjects to canvas we pass ctm. Here we try to find last not applied ctm in order to pass it to
            PdfCanvas method later. Returned ctm is written right before the image, that's why we care only for not applied ctms of
            the current (the "deepest") q/Q nesting level.
            If such ctm wasn't found identity ctm is returned.
            </remarks>
        </member>
        <member name="T:iText.PdfCleanup.PdfCleanUpProcessor.NotAppliedGsParams">
            <summary>Single instance of this class represents not applied graphics state params of the single q/Q nesting level.
                </summary>
            <remarks>
            Single instance of this class represents not applied graphics state params of the single q/Q nesting level.
            For example:
            <para />
            0 g
            1 0 0 1 25 50 cm
            <para />
            q
            <para />
            5 w
            /Gs1 gs
            13 g
            <para />
            Q
            <para />
            1 0 0 RG
            <para />
            Operators "0 g", "1 0 0 1 25 50 cm" and "1 0 0 RG" belong to the outer q/Q nesting level;
            Operators "5 w", "/Gs1 gs", "13 g" belong to the inner q/Q nesting level.
            Operators of every level of the q/Q nesting are stored in different instances of this class.
            </remarks>
        </member>
        <member name="T:iText.PdfCleanup.PdfCleanupProductInfo">
            <summary>Product info about this iText add-on.</summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanupProductInfo.PRODUCT_NAME">
            <summary>The product name.</summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanupProductInfo.MAJOR_VERSION">
            <summary>The major version number.</summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanupProductInfo.MINOR_VERSION">
            <summary>The minor version number.</summary>
        </member>
        <member name="T:iText.PdfCleanup.PdfCleanUpTool">
            <summary>Represents the main mechanism for cleaning a PDF document.</summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanUpTool.floatMultiplier">
            <summary>
            When a document with line arts is being cleaned up, there are lot of
            calculations with floating point numbers.
            </summary>
            <remarks>
            When a document with line arts is being cleaned up, there are lot of
            calculations with floating point numbers. All of them are translated
            into fixed point numbers by multiplying by this coefficient. Vary it
            to adjust the preciseness of the calculations.
            </remarks>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanUpTool.arcTolerance">
            <summary>
            Used as the criterion of a good approximation of rounded line joins
            and line caps.
            </summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanUpTool.pdfCleanUpLocations">
            <summary>Key - page number, value - list of locations related to the page.</summary>
        </member>
        <member name="F:iText.PdfCleanup.PdfCleanUpTool.redactAnnotations">
            <summary>
            Keys - redact annotations to be removed from the document after clean up,
            Values - list of regions defined by redact annotation
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.#ctor(iText.Kernel.Pdf.PdfDocument)">
            <summary>
            Creates a
            <see cref="T:iText.PdfCleanup.PdfCleanUpTool"/>
            object. No regions for erasing are specified.
            Use
            <see cref="M:iText.PdfCleanup.PdfCleanUpTool.AddCleanupLocation(iText.PdfCleanup.PdfCleanUpLocation)"/>
            method
            to set regions to be erased from the document.
            </summary>
            <param name="pdfDocument">
            A
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            object representing the document
            to which redaction applies.
            </param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.#ctor(iText.Kernel.Pdf.PdfDocument,System.Boolean)">
            <summary>
            Creates a
            <see cref="T:iText.PdfCleanup.PdfCleanUpTool"/>
            object. If
            <paramref name="cleanRedactAnnotations"/>
            is true,
            regions to be erased are extracted from the redact annotations contained inside the given document.
            Those redact annotations will be removed from the resultant document. If
            <paramref name="cleanRedactAnnotations"/>
            is false,
            then no regions for erasing are specified. In that case use
            <see cref="M:iText.PdfCleanup.PdfCleanUpTool.AddCleanupLocation(iText.PdfCleanup.PdfCleanUpLocation)"/>
            method to set regions to be erased from the document.
            </summary>
            <param name="pdfDocument">
            A
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            object representing the document
            to which redaction applies.
            </param>
            <param name="cleanRedactAnnotations">
            if true - regions to be erased are extracted from the redact annotations contained
            inside the given document.
            </param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.#ctor(iText.Kernel.Pdf.PdfDocument,System.Collections.Generic.IList{iText.PdfCleanup.PdfCleanUpLocation})">
            <summary>
            Creates a
            <see cref="T:iText.PdfCleanup.PdfCleanUpTool"/>
            object based on the given
            <see cref="!:System.Collections.IList&lt;E&gt;"/>
            of
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            s representing regions to be erased from the document.
            </summary>
            <param name="cleanUpLocations">
            list of locations to be cleaned up
            <see cref="T:iText.PdfCleanup.PdfCleanUpLocation"/>
            </param>
            <param name="pdfDocument">
            A
            <see cref="T:iText.Kernel.Pdf.PdfDocument"/>
            object representing the document
            to which redaction applies.
            </param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.SetEventCountingMetaInfo(iText.Kernel.Counter.Event.IMetaInfo)">
            <summary>
            Sets the cleanup meta info that will be passed to the <see cref="T:iText.Kernel.Counter.EventCounter"/>
            with <see cref="T:iText.PdfCleanup.Events.PdfSweepEvent"/> and can be used to determine event origin.
            <param name="metaInfo">the meta info to set.</param>
            <returns>this instance</returns>
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.CleanUp">
            <summary>
            Cleans the document by erasing all the areas which are either provided or
            extracted from redaction annotations.
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.IsProcessAnnotations">
            <summary>
            Check if page annotations will be processed
            Default: True
            </summary>
            <returns>True if annotations will be processed by the PdfCleanUpTool</returns>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.SetProcessAnnotations(System.Boolean)">
            <summary>
            Set if page annotations will be processed
            Default processing behaviour: remove annotation if there is overlap with a redaction region
            </summary>
            <param name="processAnnotations">if page annotations will be processed</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.CleanUpPage(System.Int32,System.Collections.Generic.IList{iText.PdfCleanup.PdfCleanUpLocation})">
            <summary>Cleans a page from the document by erasing all the areas which are provided or</summary>
            <param name="pageNumber">the page to be cleaned up</param>
            <param name="cleanUpLocations">the locations to be cleaned up</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.ColorCleanedLocations(iText.Kernel.Pdf.Canvas.PdfCanvas,System.Collections.Generic.IList{iText.PdfCleanup.PdfCleanUpLocation})">
            <summary>Draws colored rectangles on the PdfCanvas corresponding to the PdfCleanUpLocation objects</summary>
            <param name="canvas">the PdfCanvas on which to draw</param>
            <param name="cleanUpLocations">the PdfCleanUpLocations</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.AddColoredRectangle(iText.Kernel.Pdf.Canvas.PdfCanvas,iText.PdfCleanup.PdfCleanUpLocation)">
            <summary>Draws a colored rectangle on the PdfCanvas correponding to a PdfCleanUpLocation</summary>
            <param name="canvas">the PdfCanvas on which to draw</param>
            <param name="location">the PdfCleanUpLocation</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.AddCleanUpLocationsBasedOnRedactAnnotations">
            <summary>
            Adds clean up locations to be erased by extracting regions from the redact annotations
            contained inside the given document.
            </summary>
            <remarks>
            Adds clean up locations to be erased by extracting regions from the redact annotations
            contained inside the given document. Those redact annotations will be removed from the resultant document.
            </remarks>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.ExtractLocationsFromSingleRedactAnnotation(iText.Kernel.Pdf.Annot.PdfRedactAnnotation)">
            <summary>
            Note: annotation can consist not only of one area specified by the RECT entry, but also of multiple areas specified
            by the QuadPoints entry in the annotation dictionary.
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.TranslateQuadPointsToRectangles(iText.Kernel.Pdf.PdfArray)">
            <summary>Convert a PdfArray of floats into a List of Rectangle objects</summary>
            <param name="quadPoints">input PdfArray</param>
        </member>
        <member name="M:iText.PdfCleanup.PdfCleanUpTool.RemoveRedactAnnots">
            <summary>
            Remove the redaction annotations
            This method is called after the annotations are processed.
            </summary>
        </member>
        <member name="F:iText.PdfCleanup.TextPositioning.firstPositioningOperands">
            <summary>
            Not null only when first pos operator encountered; when concatenation of operators is performed
            this field is cleaned and positioning info is stored in either tdShift or tmShift fields.
            </summary>
        </member>
        <member name="M:iText.PdfCleanup.TextPositioning.GetCurrLeading">
            <summary>Get the current leading</summary>
        </member>
        <member name="M:iText.PdfCleanup.TextPositioning.Clear">
            <summary>is performed when text object is ended or text chunk is written</summary>
        </member>
    </members>
</doc>
